# [Python 공부 부분]

**Python 도장깨기 강의 영상 사이트: https://www.youtube.com/watch?v=Pe4bDHvNQ98&list=PLa9dKeCAyr7iWPMclcDxbnlTjQ2vjdIDD&index=1**
```
<#는 출력값을 적어둠>

명령 프롬프트(cmd)를 들어가서
python 을 치면 파이썬 셸을 이용하여 파이썬을 사용할 수 있음.
명령 프롬프트에서 파이썬 셸을 끝내려면 exit()과 엔터를 입력하거나 Ctrl+z와 엔터를 입력하면 된다.

명령 프롬프트에서
cd Desktop\프로그래밍 독학\파이썬 (도장깨기 현재 단계) 입력하고
python hello.py 입력하면 스크립트 파일 실행 가능하다.

python IDLE 에서 윗코드를 복사해서 다시 가져오고싶다면, 해당 코드를 마우스로 클릭하고 엔터를 치면 된다.

파이썬에서는 들여쓰기 자체가 문법이기때문에 꼭 주의해서 사용해야한다.
파이썬 들여쓰기 방법: 공백(스페이스바) 2칸 or 공백(스페이스바) 4칸 or 탭(Tab키) 1칸 => 하지만 공백 4칸이나 탭 1칸을 추천한다.

int에 문자열을 넣어도 정수로 만들 수 있지만, 단, 정수로 된 문자열만 넣어야 한다.
예를들어, int('10')을 입력하면 10이라고 정상적으로 출력되지만,
int('10.3)을 입력하게되면 에러가 난다.

몫과 나머지를 함께 구하는 함수
예) divmod(5, 2) 입력하면 (2, 1) 출력

값을 괄호로 묶은 형태를 튜플(tuple)이라고 한다.
예를들어, (2, 1)

2진수: 숫자앞에 0b를 붙인다. 0과 1을 사용.
8진수: 숫자앞에 0o를 붙인다. 0부터 7까지 사용.
16진수: 숫자앞에 0x 또는 0X를 붙인다. 0부터 9와 A부터 F까지 사용(소문자 a부터 f까지도 가능).
0b110입력하면 6이 출력되는 이유: 2진수로 110이면, 2의2제곱x1 + 2의1제곱x1 + 2의0제곱x0 = 4+2+0 = 6 이기때문이다.

나눗셈 연산자 /의 결과는 실수, //의 결과는 정수, %의 결과는 정수이다.

type(a): 변수 a의 자료형이 무엇인지 출력해준다.

del a: 변수 a 삭제

input(): c언어의 scanf와 같은 용도인 입력 함수이다.
참고로 input으로 입력한 정보는 문자열로 저장된다.
응용 예: a = input('문자열을 입력하세요: ')

정수형을 유니코드 문자형으로 바꿀때 chr 사용.
n = int(input())
print(chr(n))  // n에 저장되어 있는 정수 값을 유니코드 문자(chracter)로 바꿔 출력한다. 
예를들어 n에 65를 입력하면, 출력은 A가 된다.

문자형을 유니코드 정수형으로 바꿀때 ord 사용.
c = ord(input())
print(c)
예를들어 c에 A를 입력하면, 출력은 65가 된다.

문자열 2가지를 입력하는 방법은 예를 들어
a, b = input('문자열 2개를 스페이스바로 구분하여 입력하세요: ').split()
만약 공백이 아닌, 콤마(,)로 구분하고싶다면 split(',')으로 변경하여 사용하면 된다.
여기서 꿀팁은, 아예 한번에 a와 b를 문자열이 아닌 다른 자료형으로 바꿔주고싶다면,
a, b = map(int, input('문자열 2개를 스페이스바로 구분하여 입력하세요: ').split()) 이런식으로 적어주면된다.

print(1, 2, 3)  #1 2 3
print('hello', 'world')  #hello world
print(1, 2, 3, sep = ', ')  #1, 2, 3
print(1, 2, 3, sep = '\n')  #1엔터2엔터3
print('1\n2\n3')  #1엔터2엔터3
print(1, end=''); print(2, end=''); print(3)  #123

\ 문자 자체를 출력할때에는 \\ 이렇게 \를 두번 써야 한다.

1 == 1.0  #True
1 != 1.0  #False
1 is 1.0  #False
1 is not 1.0  #True
단, is와 is not 은 객체 비교이기때문에 값을 비교할때는 사용하면 안된다. 결과값이 잘못 나올수있음.

식 하나에 and, or, not 논리연산자가 모두 들어있으면, not, and, or 순으로 판단함.
not True and False or not False  #True
위는 ((not True) and False) or (not False) 이렇게와 같다.

bool(1)  #True
bool(0)  #False
bool(1.5)  #True
bool(0.0)  #False
bool(False)  #False
bool('False')  #True
bool(' ')  #True
bool('')  #False

파이썬에서는 논리연산자 할때 단락 평가(앞이 맞으면 뒤 값을 보지도않음)에 따라 반환값이 결정된다.
첫번째 값까지만 봐도 된다면 첫번째 값을 반환하고, 두번째 값까지 판단해야한다면 두번째 값이 반환된다. 이게 바로 단락 평가이다.
True and 'abc'  #'abc'
'abc' and True  #True
True or 'abc'  #True
'abc' or True  #'abc'
False and 'abc'  #False
0 and 'abc'  #0  0은 False이므로 and 연산자는 두번째 값을 평가하지 않음.

' '와 " "와 ''' '''와 """ """ 는 모두 결과가 똑같이 나온다.
hello = """hello world""" 다음에 hello를 출력하면 'hello world'가 나온다.

참고로 ''' '''와 """ """는 엔터 입력이 가능하다.
예를들어 hello = '''
hello world
'''
이런식으로 해도 출력이 된다.
참고로 이 방법을 사용할 시, '''와 ''' 사이에 다른 따옴표를 넣어도 관계없이 잘 작동하게 된다.

=========리스트 & 튜플=========

리스트 = [값, 값, 값]
예를들어 a = [38, 21, 53, 62] 이면은, 리스트에 저장된 각 값인 요소(element)는 38, 21, 53, 62 이다.

리스트는 문자열, 정수, 실수, 불(bool) 등 모든 자료형을 저장할 수 있으며 자료형을 섞어서 저장해도 된다.
예를들어 a = ['james', 17, 14.3, True]

빈 리스트 만드는법:
리스트 = [] 또는 리스트 = list()
예를들어 a = [] 또는 b = list() 이면, a를 출력하면 [], b를 출력하면 []가 나온다.

a = list(range(10))
a를 출력하면 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

a = list(range(3, 10))
a를 출력하면 [3, 4, 5, 6, 7, 8, 9]

a = list(range(-4, 10, 2))
a를 출력하면 [-4, -2, 0, 2, 4, 6, 8]

-----------------------

튜플은 리스트와는 다르게 안에 저장된 요소를 변경, 추가, 삭제를 할 수 없다.
읽기 전용 리스트라고 할 수 있다.

튜플 = (값, 값, 값)
튜플 = 값, 값, 값
a = (38, 24, 67)
a = 38, 24, 67
요소가 한 개인 튜플을 만들때: a= (38, ) 또는 a = 38,

튜플도 리스트처럼 여러 자료형을 섞어서 저장해도됨.

a = tuple(range(10))
a를 출력하면 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

a = tuple(range(3, 10))
a를 출력하면 (3, 4, 5, 6, 7, 8, 9)

a = tulple(range(-4, 10, 2))
a를 출력하면 (-4, -2, 0, 2, 4, 6, 8)

-----------------------

튜플과 리스트는 요소를 변경, 추가, 삭제할 수 있는지 없는지만 다를 뿐 기능과 형태는 같음.
튜플을 리스트로 만들거나, 리스트를 튜플로 만들 수 있음.

리스트를 튜플로 만드는 경우
예를들어 a= [1, 2, 3] 를 적고
tuple(a) 를 출력하면 (1, 2, 3)으로 출력된다.

리스트를 튜플로 만드는 경우
예를들어 a= (1, 2, 3) 를 적고
list(a) 를 출력하면 [1, 2, 3]으로 출력된다.

a = [10, 20, 30]
30 in a 입력하면 True 출력됨. 같은 말은 30 in [10, 20, 30]
30 not in a 입력하면 False 출력됨.
위의 것들은 리스트 뿐만 아니라 튜플에도 적용됨.

list(range(0, 10)) + list(range(10, 20))
위는 튜플(tuple)도 가능.
이처럼 리스트나 튜플안에 range 넣어서 연결은 되는데, range만 써서 둘이 더해서 연결하는건 에러남.

list(range(0, 5, 2)) * 3
위는 튜플(tuple)도 가능.
하지만 range만 쓰게될 경우 여러번 출력하는 *(곱셈) 사용도 안된다.

a = [0, 1, 2] 적고
len(a) 출력하면 3이 출력된다.

============================

1 in range(10)  #True
'P' in 'Hello Python'  #True

hello1 = 'hi, shj'
hello2 = '안녕하세요'
len(hello1)  #7
len(hello2)  #5

a = [38, 21, 53, 62, 19]
a[-1]  #19
a[-5]  #38

a = (0, 0, 0, 0, 0)
a[0] = 38 이렇게 입력하면 에러남.
그 이유는 위가 리스트라면 가능하지만, 튜플은 요소를 변경할수 없기때문에 에러가 난다.
=> 튜플은 읽기 전용이기때문이다.

r = range(0, 10, 2)
r[2]  #4
r0] = 3 이걸 입력하면 튜플이라 요소를 변경할 수 없어 에러가 난다.
=> 튜플은 읽기 전용이기때문이다.

del a[2]: 인덱스2의 요소 삭제 (튜플은 안됨)
a = [12, 54, 33]
del a[2]
a  #[12, 54]

a = 'abcd efgh' (튜플과 마찬가지로 문자열도 요소 변경 불가능하다)
a[0] = b  #에러난다
del a[0]  #에러난다

a = [0, 1, 2, 3, 4, 5]
a[0:3]  #[0, 1, 2]  인덱스0부터 인덱스2(인덱스3 전)까지 출력함.
a[:3]  #[0, 1, 2]  인덱스0부터 인덱스2(인덱스3 전)까지 출력함.
a[:]  #[0, 1, 2, 3, 4, 5]  리스트 전체를 출력함.
a[3:-1]  #[3, 4]  인덱스3부터 인덱스-2(인덱스-1 전)까지 출력함.
음수 인덱스는 뒤에서부터 차례대로 인덱스 -1, -2, -3, -4, -5, -6

{시퀀스 슬라이스}
a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
a[2:8:3]  #[2, 5]  인덱스2부터 인덱스를 3씩 증가시키면서 인덱스7(인덱스8 전)까지 출력함.
a[:7:2] #[0, 2, 4, 6]  인덱스0부터 인덱스를 2씩 증가시키면서 인덱스6(인덱스2 전)까지 출력함.
a[3::2]  #[3, 5, 7, 9]  인덱스3부터 인덱스를 2씩 증가시키면서 쭉 리스트 끝까지 출력함.
a[::2]  #[0, 2, 4, 6, 8]  인덱스0부터 인덱스를 2씩 증가시키면서 쭉 리스트 끝까지 출력함.
a[::]  #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  리스트 전체를 출력함.
a의 마지막 인덱스인 a[9]를 출력하고싶으면, a[len(a) - 1]을 입력하고,
a의 첫번째 인덱스부터 a의 마지막 인덱스인 a[9]까지 모두 출력하고싶으면 a[0:len(a)]를 입력해야한다.
튜플, range, 문자열도 시퀀스 자료형이므로 리스트와 같은 방식으로 슬라이스를 사용할 수 있음.

a = [0, 1, 2, 3, 4, 5, 6]
a[2:5] = ['a', b', c']
a  #[0, 1, 'a', b', c', 5, 6]

b = [0, 1, 2, 3, 4, 5, 6]
b[2:5] = ['b']
b  #[0, 1, 'b', 5, 6]

c = [0, 1, 2, 3, 4, 5, 6]
c[1:6:2] = ['a', 'b', 'c']
c  #[0, 'a', 2, 'b', 4, 'c', 6]

위의 것들은 요소 할당이므로 리스트와는 달리 튜플과 range와 문자열은 사용 불가능하다.
마찬가지로, 슬라이스 삭제인 del은 리스트와는 달리 튜플과 range와 문자열은 사용 불가능하다.

===========딕셔너리===========

딕셔너리는 사전(dictionary)에서 단어를 찾듯이 값을 가져올 수 있다고 하여 딕셔너리라고 부름.
딕셔너리는 특정 주제에 대해 연관된 값을 저장할 때 사용한다.

딕셔너리 = {키1: 값1, 키2: 값2}
키에는 값을 하나만 지정할 수 있으며, 이런 특성을 따서 키-값 쌍(key-value pair)이라고 부름 (키-값은 1:1 대응).

lux = {'health': 490, 'health': 800, 'mana': 334, 'armor': 18.72}
lux['health']  #800  키 중복되면 뒤에 값만 사용함.
lux  #{'health': 800, 'mana': 334, 'armor': 18.72}  중복되는 키는 저장되지 않음.

딕셔너리의 키는 문자열뿐만 아니라 정수, 실수, 불(bool)도 사용할 수 있으며 자료형을 섞어서 사용해도 됨.
값에는 리스트, 딕셔너리 등을 포함하여 모든 자료형을 사용할 수 있음.
단, 키에는 리스트, 딕셔너리를 사용할 수 없음.

빈 딕셔너리 만드는 법
딕셔너리 = {}
딕셔너리 = dict()
예를들어 a = {} 또는 b = dict() 이면, a를 출력하면 {}, b를 출력하면 {}가 나온다.

딕셔너리 만드는 여러가지 방법 예) lux = {'health': 800, 'mana': 334, 'armor': 18.72}
- 딕셔너리 = dict(키1=값1, 키2=값2)   이건 참고로 따옴표쓰면 안된다.
lux = dict(health = 800, mana = 334, armor = 18.72)
- 딕셔너리 = dict(zip([키1, 키2], [값1, 값2]))
lux = dict(zip(['health', 'mana', 'armor'], [800, 334, 18.72]))
- 딕셔너리 = dict([(키1, 값1), (키2, 값2)])
lux = dict([('health', 800), ('mana', 334), ('armor', 18.72)])
- 딕셔너리 = dict({키1: 값1, 키2: 값2})
lux = dict({'health': 800, 'mana': 334, 'armor': 18.7})
- 딕셔너리 = {키1: {키A:값A, 키B,값B, 키C:값C}, 키2: {키A:값A, 키B,값B, 키C:값C}}  // 중첩 딕셔너리이다. 출력할때는 2차원 딕셔너리처럼 생겼다.
lux = {
	'status': {
		'health': 800,
		'mana': 334,
		'armor': 18.72
	},
	'other': {
		'hello': 100,
		'world': 200,
		'python': 300
	}
}
print(lux['status']['mana'])  #334

lux = {'health': 800, 'mana': 334, 'armor': 18.72}   키:값
len(lux)  #3
len({'health': 800, 'mana': 334, 'armor': 18.72})  #3
lux['health']  #800  // 이런 특정 키를 입력하여 값을 출력하는 코드는 lux.get('health')와 같다.
lux[800]  #에러난다
lux[없는 키]  #에러난다
lux['health'] = 200  이렇게 값 변경가능하다. (해당 키에 맞는 값을 수정)
lux['hello'] = 3000  이렇게 키와 값 추가가 가능하다. (키와 값을 새로 추가)
lux.setdefault('world')  // 'world' 키를 새로 추가해주고, 값에 빈값인 none을 추가해준다. (키와 빈값 추가)
lux  #{'health': 200, 'mana': 334, 'armor': 18.72, 'hello': 3000, 'world': None}
lux.setdefault('shj', 23)  // 키로 'shj'와 값으로 23을 새로 추가해준다. (키와 값을 새로 추가)
lux  #{'health': 200, 'mana': 334, 'armor': 18.72, 'hello': 3000, 'world': None, 'shj': 23}
lux.update(shj=100)  // 'shj' 키의 값을 100으로 변경한다. (해당 키에 맞는 값을 수정)
		 // 그리고 예를들어 x.update(a=900, b=200) 이렇게 여러개도 함께 변경이 가능하다.
lux  #{'health': 200, 'mana': 334, 'armor': 18.72, 'hello': 3000, 'world': None, 'shj': 100}
lux.update({'health': 600, 'hey':'3400'})
lux  #{'health': 600, 'mana': 334, 'armor': 18.72, 'hello': 3000, 'world': None, 'shj': 100, 'hey': '3400'} (있는 키는 값만 변경, 없는 키는 새로 키와 값 생성.)
lux.pop('shj')  // 'shj'가 키인 키-값을 제거 (특정 키-값 쌍을 제거), 같은 말로는 del lux['shj']가 있다.
lux  #{'health': 600, 'mana': 334, 'armor': 18.72, 'hello': 3000, 'world': None, 'hey': '3400'}
'health' in lux  #True
'kakao' not in lux  #True
lux.clear()  // lux 딕셔너리의 모든 키-값 쌍을 삭제함.
lux  #{}

============================

if 조건식:
	코드
예를들어
x = int(input())
if(x == 10):
	print('x는 10입니다.')
print('hello python')

if문에서 0은 False로, None은 False으로, 문자열은 내용이 있을때는 True로, 빈 문자열은 False로 취급된다.
if 0:  거짓이다.
if None:  거짓이다.
if 'Hello'  참이다.
if ''  거짓이다.

x = 0
if x:
	print('True')
else:
	print('False')
이것은 False가 출력된다.

C언어에서는
if(x==10 && y==20) 이렇게쓰지만,
파이썬에서는
if(x==10 and y==20): 이렇게나 if((x==10) & (y==20)): 이렇게 쓴다. 잘못된 예로는 if(x==10 & y==20): 와 if((x==10) && (y==20)): 가 있다.
헷갈리니 그냥 괄호 다쓰고 and 로 사용하자. or도 마찬가지로.
참고로 가장바깥쪽 괄호는 쓰나마나 상관없음.

파이썬에서는 if문에 조건식으로 x>0 and x<20 이렇게 쓸필요없고, 간단하게 0<x<20 이렇게 쓰면 된다.

if:
elif:
elif:
else:
순서이다.

for 변수 in range(횟수):
	반복할 코드
이건 0부터 횟수전의 숫자까지 반복한다.
참고로 i=0같은걸 미리 선언하지않아도 된다. 이미 0부터 시작이란뜻이 for in range에 포함되어있기때문이다.

for i in range(5):
	print('helllo world', i)
# helllo world 0
helllo world 1
helllo world 2
helllo world 3
helllo world 4

for i in range(5, 12):
이거는 5부터 11(12전)까지 반복하는 for문이다.
5~11까지 (11-5+1=7번 반복한다)

for i in range(0, 10, 2)  // 이건 0부터 10전까지(9까지) 2씩 증가한 숫자중에서 반복한다. 즉 0부터 짝수만.
여기서 헷갈릴만한점은 역순방향은 좀 다르다는 것이다.
for i in range(10, 0, -1)  // 10에서 0후까지(1까지) 역순으로 -1씩 해가며 반복한다.

for에 range대신 시퀀스 객체를 넣어도 됨.
예를들어
a = [10, 20, 30]
for i in a:
	print(i)
# 10
20
30

문자열도 시퀀스 객체이므로
munjayul = ('abc', 'def', 'ghi')
for str in munjayul:  // 'munjayul 안에서 str을 위한' 이라고 이해해보자
사용가능하다.

for letter in 'Python':
	print(letter, end = ' ')
# P y t h o n
근데 이걸 for letter in reversed('Python'): 이렇게 쓰면  #n o h t y P

i = 0
while i<5:
        print('Hello world')
        i+=1
# Hello world
Hello world
Hello world
Hello world
Hello world
참고로 파이썬에서는 i++은 못쓰는듯 하다.

from random import *
print(randint(1, 6))
이거와
import random
print(random.randint(1, 6))
이거는 같다.
1~6 숫자중 랜덤숫자 추출한다.

while:
	print(i)
	i+=1
	if(조건)
	break
이것과
for i in  range(숫자):
	print(i)
	if(조건)
	break
이것은 차이점이 있다.
바로 i가 어디까지 출력되냐이다.
그 이유는 만약에 조건문에 i==10이라고 가정하고,
위 두 코드들 모두 조건을 충족시킨 상태라 하면,
위의 while문은 9까지 출력되다가 바로 while문을 탈출하는 반면에,
위의 for문은 range 때문에 9출력하고 조건문 충족하지 못했기때문에 다시 올라가서 10을 출력하고 그다음에 조건문을 충족해서 for문을 탈출한다.
즉, 위의 while문은 9까지, 위의 for문은 10까지 출력된다.

topics = [
    {'id':1, 'title':'routing', 'body':'Routing is ..'},
    {'id':2, 'title':'view', 'body':'View is ..'},
    {'id':3, 'title':'Model', 'body':'Model is ..'},
]
def index(request):
    global topics
    ol = ''
    for topic in topics:
        ol += f'<li>{topic["title"]}</li>'  // f는 파이썬의 f-string 이라는 문자열 포매팅 방법인데, 더 자세한 내용은 https://blockdmask.tistory.com/429 에 있다.
				// 요약하자면, 반복문등등에서 중간에 짧은거 하나만 바꾸면되는데 다른것도 바꿔주느라 코드가 무지 길어지는것을
				// 방지하기위해 f{}를 사용하여 {} 안의 값만 변경하게해주는 문자열 포매팅 방법이다.
				// 사용방법은 문자열(따옴표로 묶여있는것들 등등)의 맨 앞에(따옴표앞) f를 붙이고, 사용하고 싶은 변수, 값을 중괄호 안에 넣는다. 그리고 출력한다.

if문의 조건식을 만족한다면, if문 안의 continue 코드줄 바로 아래에있는 코드는 실행하지않고,
건너뛰어서 다시 if문을 감싸고있는 for문으로 돌아간다.

break와 continue의 차이점은
break는 조건을 만족한다면 해당 반복루프를 탈출하여 나가버리지만,
continue는 조건을 만족한다면 그 밑의 코드만 실행안하고 건너뛸뿐이고 다시 반복루프로 돌아가서 마저 계속해서 실행한다.

print문은 파이썬에선 기본적으로 엔터기능이 탑재되어있음.
그렇기에 반복문 안의 print문 안에 end='' 이것을 넣어주면 자동엔터가 되어 자동줄바꿈 하는것을 방지해준다.

'hello' * True  #'hello'  그 이유는 어떤것이든간에 True 즉, 1을 곱하면 결과값으로 그대로 똑같이 나오기때문이다.
'hello' * False  #''  그 이유는 어떤것이든간에 False 즉, 0을 곱하면 결과값으로 나오는게 없기때문이다.

FizzBuzz 짧게 단축한 프린트출력문장
print('Fizz' * (i%3==0) + 'Buzz' * (i%5==0) or i)

터틀 그래픽스
import turltle as t  // 터틀 그래픽스 코드를 t로 치환한다.
t.shape('turtle')  // t의 모양을 거북이 모양으로 지정한다.
t.forward(100)  // 거북이를 앞으로 100만큼 전진한다.

t.begin_fill()  // 색칠할 영역 시작
t.end_fill()  // 색칠할 영역 끝
t.circle(120)  // 반지름이 120인 원 그리기
t.speed('fastest')  // 거북이 속도를 가장 빠르게 설정

리스트를 조작하는 메서드(method)
요소 추가하기
append: 요소 하나를 추가, extend: 리스트를 연결하여 확장(리스트에 리스트 넣고 넣은 리스트는 괄호 제거), insert: 특정 인덱스에 요소 추가
a = [10, 20, 30]
a.append(500)
a  #[10, 20, 30, 500]
a.append([600, 700])  // 리스트안에 리스트 넣기 가능하다
a  #[10, 20, 30, 500, [600, 700]]
a.extend([800, 900])  // 리스트를 연결한다. 넣는 거는 리스트 괄호 빠짐.
a  #[10, 20, 30, 500, [600, 700], 800, 900]
a.insert(2, 25)  // insert(인덱스, 요소)  인덱스2번째에 25라는 요소를 추가로 삽입한다.
a  #[10, 20, 25, 30, 500, [600, 700], 800, 900]
a.insert(1, [5, 7])  // insert로 리스트도 넣을 수 있다.
a  #[10, [5, 7], 20, 25, 30, 500, [600, 700], 800, 900]
a[1:1] = [1, 2]  #extend와 insert를 합친듯한 메서드 사용이다. 인덱스1 자리에 리스트를 삽입하되, 괄호 제거하고 삽입한다.
a  #[10, 1, 2, [5, 7], 20, 25, 30, 500, [600, 700], 800, 900]

요소 삭제하기
pop: 마지막 요소 또는 특정 인덱스의 요소를 삭제하고 shell에서는 삭제할 값을 출력해줌, remove: 특정 값을 찾아서 삭제
a = [10, 20, 30, 40, 50, 60]
a.pop()  #60
a  #[10, 20, 30, 40, 50]
a.pop(1)  #20  // 대신 del a[1] 을 사용해도 됨.
a  #[10, 30, 40, 50]
a.remove(30)
a  #[10, 40, 50]

a = [0, 10, 20, 30, 40]
a.index(20)  #2  // 리스트에서 특정 값의 인덱스 구하기 (이건 요소의 값을 변경하는게 아닌, 그저 정보를 찾거나 이용하는 메서드이므로 튜플도 사용이 가능하다.)
a.reverse()  // 리스트에서 요소의 순서를 반대로 뒤집음
a  #[40, 30, 20, 10, 0]
a = [20, 30, 20, 20, 40, 50]
a.count(20)  #3  // 리스트에서 특정 값의 개수를 구함 (이건 요소의 값을 변경하는게 아닌, 그저 정보를 찾거나 이용하는 메서드이므로 튜플도 사용이 가능하다.)
a = [1, 3, 2, 6, 5]
a.sort()  // 리스트에서 요소를 작은 순서대로(작은거부터) 정렬함(오름차순), a.sort(reverse=False) 도 같은 말임.
a  #[1, 2, 3, 5, 6]
a.sort(reverse=True)  // 리스트에서 요소를 큰 순서대로(큰거부터) 정렬함(내림차순)
a  #[6, 5, 3, 2, 1]
a.clear()  // 리스트의 모든 요소를 삭제함. 대신 del a[:]로 사용해도 됨.
a  #[]

리스트.sort()와 sorted(리스트)의 가장 큰 차이는
리스트.sort() 는 본체의 리스트를 정렬해서 변환하는 것이고,
sorted(리스트) 는 본체 리스트는 내버려두고, 정렬한 새로운 리스트를 반환하는 것이다.

a = [10, 20, 30]
a[len(a):] = [500, 600]  // 리스트 끝에 값이 한 개 이상 들어있는 리스트를 추가함. 괄호없이 추가하면 에러남.
		   // 예를들어 한개의 값 [500] 이렇게만 추가면 a.append(500) 과 동일하게 사용이 가능함.
		   // 하지만 [500, 600] 이렇게 두개 이상의 값 추가면, a.append([500, 600])과는 사용이 달라진다.
		   // 그 이유는 이건 리스트에 추가할때 괄호가 빠진다음 추가가 되지만, 반면에 a.append([500, 600])는 괄호 그대로 [500, 600]이 추가되기 때문이다.
a  #[10, 20, 30, 500, 600]

a = [1, 2, 3] 을 전제로 해놓고, (여기부터 내용은 리스트 뿐만아니라 딕셔너리에도 똑같이 적용되는 말이다.)
b = a로 적으면 둘이 같은 객체로 통일되어 a is b를 출력해보면 True가 나오고, a==b를 출력해보면 True가 나오고, 중간 요소를 하나 변경하면 a와 b모두 함께 변경되지만,
b = a.copy()로 적으면 요소 내용만 복사되고 객체는 서로 다르므로 a is b를 출력해보면 False가 나오고, a==b를 출력해보면 True가 나오고, 중간 요소를 하나 변경해도 둘중 하나만 변경된다.
(근데 이상하게도 2차원 배열 리스트는 copy 사용하고 요소 하나만 변경해도 a와 b 리스트 모두 함께 변경된다. 중첩 딕셔너리인 2차원 딕셔너리도 마찬가지이다.
이를 막으려면 copy 모듈의 deepcopy 함수를 사용해야한다. 예를들어
a = 리스트나 중첩 딕셔너리
import copy
b = copy.deepcopy(a)
이렇게 사용하면 하나의 값을 바꿔도 그 객체 하나만 바뀌고 다른 객체는 그대로 유지된다.)
a is b는 둘이 같은 객체냐고 묻는 의미이고,
a == b는 둘이 안의 값이 같냐고 묻는 의미이다.

파이썬의 리스트는 리스트 안에 for 반복문과 if 조건문을 사용할 수 있다.
a = [i for i in range(10)]  // 0부터 9까지 숫자를 생성하여 리스트 생성
a  #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
b = list(i for i in range(10))  // 0부터 9까지 숫자를 생성하여 리스트 생성
c = [i+5 for i in range(10)]  // c = [(i+5) for i in range(10)] 와 동일하며, 0부터 9까지 숫자를 생성하여 리스트를 생성하면서 각 요소에 5를 더해준다.
c  #[5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
d = [i for in range(10) if i%2==0]  // 0부터 9 숫자중 2의 배수인 숫자(짝수)로 리스트 생성
d  #[0, 2, 4, 6, 8]

2단부터 9단까지 구구단 리스트 생성
a = [i * j for j in range(2, 10)
            for i in range(1, 10)]      // 리스트 표현식에 for가 여러개일때 처리순서가 뒤에서 앞으로 순이라고하여,
			    // 보기쉽게 표현하자면  for j(2~9)
					           {
					    	       for i(1~9)
					           }     인것이다.
			    // j가 2단으로 고정될때 i는 1~9까지 순환되는 방식이다.

map은 요소를 지정된 함수로 처리해주는 함수이다.(원본 리스트를 변경하지않고 새 리스트를 생성)
- list(map(함수, 리스트))
- tuple(map(함수, 튜플))
a = [1.2, 2.4, 6.2, 7.8]
b= list(map(int, a))  // a라는 리스트를 정수화 시켜서 b라는 리스트에 다시 넣어달라는 의미이다. b가 아닌 a로 하면 요소 변경인것이나 마찬가지다.
b  #[1, 2, 6, 7]  // [int(a[0]), int(a[1]), int(a[2]), int(a[3])]

a = input('문자열 2개를 스페이스바로 구분하여 입력하세요: ').split()
여기서 a의 결과값은 문자열 리스트이다. 예를들어 1 3 을 입력했다면, a의 출력값은 ['1', '3'] 이다.

a = input('문자열 2개를 스페이스바로 구분하여 입력하세요: ').split()  // 1 3을 입력했다고 가정하자. 그러면 a에 ['1', '3']을 저장.
b = map(int, a)  // b에 [1, 3]을 저장.
a, c = b  // a에 1을, c에 3을 저장.
a  #1
b  #3

2차원 배열
00 01 02 03
10 11 12 13
20 21 22 23

2차원 리스트 예
a = [[10, 20],
      [30, 40],
      [50, 60]]  // 엔터 굳이 안쳐도되긴하는데, 가독성을 위해 이렇게 입력해도 무방함.
a[2][1]  #60

for 반복문으로 2차원 리스트 요소 모두 출력하기
a = [[10, 20], [30, 40], [50, 60]]
for x, y in a:
	print(x, y)
이거 아니면
for i in range(len(a)):  //  세로가 [10, 20]과 [30, 40]과 [50, 60]로 3줄이므로 len(a)=3 이다. 세로 크기이다.
	for j in range(len(a[i])):  //  [10, 20]인 줄이 10과 20으로 쪼개지므로, len(a[i])=2이다. 가로 크기이다.
		print(a[i][j], end = ' ')
	print()

while 반복문으로 2차원 리스트 요소 모두 출력하기
a = [[10, 20], [30, 40], [50, 60]]
i = 0
while i<len(a):
	x, y = a[i]
	print(x, y)
	i+=1
이거 아니면
i = 0
while i < len(a):
	j = 0
	while j < len(a[i]):
		print(a[i][j], end = ' ')
		j += 1
	print()
	i += 1
 
문자열 왼쪽 정렬
print('python'.ljust(10))  #'python    '  // 실제론 따옴표(' ')가 출력되진 않음. 내가 구분하기쉽게 적어둔것일뿐임.
문자열 오른쪽 정렬
print('python'.rjust(10))  #'    python'  // 실제론 따옴표(' ')가 출력되진 않음. 내가 구분하기쉽게 적어둔것일뿐임.
문자열 가운데 정렬
print('python'.center(10))  #'  python  '  // 실제론 따옴표(' ')가 출력되진 않음. 내가 구분하기쉽게 적어둔것일뿐임.

메서드 체이닝: 메서드를 줄줄이 연결해서 사용
다음은 문자열을 오른쪽으로 정렬한 뒤 대문자로 바꿈
print('python'.rjust(10).upper())  #'    PYTHON'  //// 실제론 따옴표(' ')가 출력되진 않음. 내가 구분하기쉽게 적어둔것일뿐임.

왼쪽부터 문자열 위치 찾기
print('apple pineapple'.find('pl'))  #2  // 'pl'이 시작되는 첫 인덱스 번호인 2를 출력함.
print('apple pineapple'.find('xy'))  #-1  // 찾는 문자열이 없으므로 -1을 출력함.
오른쪽부터 문자열 위치 찾기
print('apple pineapple'.rfind('pl'))  #12  // 오른쪽에서 'pl'이 시작되는 첫 인덱스 번호인 12를 출력함.
print('apple pineapple'.rfind('xy'))  #-1  // 찾는 문자열이 없으므로 -1을 출력함.

a = "qwer"
print(a.find('w'))  # 1
print(a.find('w', 2))  # -1  // find('문자', 검색시작위치인덱스) 로 인덱스 2부터 'w'를 검색하였고, 없어서 -1을 출력함.

'Hello my name is %s, and %d years old' %('shj', 23)  #'Hello my name is shj, and 23 years old'

format 메서드 사용해서 출력하는 방법은 이전 기초 파이썬 필기 파일에서 확인 할 수 있다.

x = {'a':10, 'b':20, 'c':30}
x.items()  #dict_items([('a', 10), ('b', 20), ('c', 30)])  // 키와 값 모두 출력
x.keys()  #dict_keys(['a', 'b', 'c'])  // 키만 모두 출력
x.values()  #dict_values([10, 20, 30])  // 값만 모두 출력
여기서 반복문으로 딕셔너리의 키-값 쌍을 모두 출력하는 코드는
for key, value in x.items():
	print(key, value, end='  ')
# a 10  b 20  c 30
만약 키만 출력하고 싶다면
for i in x.keys():
	print(i, end=' ')
# a b c
만약 값만 출력하고 싶다면
for i in x.values():
	print(i, end=' ')
# 10 20 30

세트는 수학에서의 집합과 같다.
세트 = {값1, 값2, 값3}
세트를 출력해보면 매번 요소의 순서가 다르게 나온다.
세트에 들어가는 요소는 중복될 수 없다. 중복해서 값을 넣었다면, 출력할때는 한번만 나온다.
세트는 인덱스로는 특정값을 불러내서 출력할수없다. 순서가 뒤죽박죽이기 때문이다. 특정값이 있는지 확인하려면 in 이나 not in 을 사용하면 된다.

a = set('apple')
a  #{'e', 'l', 'a', 'p'}

b = set(range(5))
b  #{0, 1, 2, 3, 4}

c = set()
c  #set()

c = {}
type(c)  #<class 'dict'>

c = set()
type(c)  #<class 'set'>

합집합 세트
- 세트1 | 세트2
- set.union(세트1, 세트2)
a = {1, 2, 3, 4}
b = {3, 4, 5, 6}
a | b  #{1, 2, 3, 4, 5, 6}
set.union(a, b)  #{1, 2, 3, 4, 5, 6}

교집합 세트
- 세트1 & 세트2
- set.intersection(세트1, 세트2)
a = {1, 2, 3, 4}
b = {3, 4, 5, 6}
a & b  #{3, 4}
set.intersection(a, b)  #{3, 4}

차집합 세트
- 세트1 - 세트2
- set.differnce(세트1, 세트2)
a = {1, 2, 3, 4}
b = {3, 4, 5, 6}
a - b  #{1, 2}
set.differnce(a, b)  #{1, 2}

대칭차집합 세트  // XOR을 서로 다르면 참이므로, 서로 겹치지 않는 요소만 출력함.
- 세트1 ^ 세트2
- set.symmetric_differnce(세트1, 세트2)
a = {1, 2, 3, 4}
b = {3, 4, 5, 6}
a ^ b  #{1, 2, 5, 6}
set.symmetric_differnce(a, b)  #{1, 2, 5, 6}

|= 이거나 &= 이거나 -= 이거나 ^= 사용 가능하다.
예를들어
a = {1, 2, 3, 4}
a |= {112}  // 같은 말로는 a.update({112}) 가 있다.
	  // &= 일경우는 intersection_update 로 교체하여 사용함.
       	  // -= 일경우는 differnce_update 로 교체하여 사용함.
	  // ^= 일경우는 symmetric_differnce_update 로 교체하여 사용함. 
a  # {1, 2, 3, 4, 112}
b = {3, 4, 5, 6}
a ^= b
a  #{1, 2, 5, 6, 112}
b  #{3, 4, 5, 6}

a = {1, 2, 3}
a <= {1, 2, 3, 4, 5}  #True  // {1, 2, 3}이 {1, 2, 3, 4, 5}에 포함되는가? 라는 의미이다. 같은말로는 a.issubset({1, 2, 3, 4, 5})
<= 부분집합인데 같을때도 포함해서 참이다.
< 는 부분집합이지만 같지는 않을때 참이다.
>=는 issubset 대신 issuperset으로 사용한다.
disjoint는 현재 세트가 다른 세트와 겹치는 요소가 존재하지않을때 True를 반환한다.

세트 요소 조작하기
a = {1, 2, 3, 4}
a.add(5)  // 요소 5 추가
a.remove(5)  // 요소 5 제거, 해당 요소 없으면 에러남.
a.discard(5)  // 요소 5 제거, 해당 요소 없어도 에러없이 그냥 넘어감.
a.pop()  // 요소를 랜덤으로 하나 제거. 제거한 요소를 반환함. 요소가 없다면 에러남.
a.clear()  // 요소 모두 삭제

파이썬에서 전역변수를 선언하는 방법은 변수명 앞에 global을 붙이는 것이다.
함수 안에서 global을 붙여도 되고, 함수 밖에서 global을 붙여도 된다.
하지만 함수 밖에서 선언하였다면 함수 안에서도 사용을 명시해주어야 한다.
쉽게 설명하자면, 각 함수마다 예를들어 global a 이렇게 모두 적어주어야한다.

파이썬 라이브러리로 알파벳이나 숫자 목록이 담긴 리스트를 만들 수 있다.
import string 
// string.ascii_lowercase 는, 소문자 abcdefghijklmnopqrstuvwxyz
// string.ascii_uppercase 는, 대문자 ABCDEFGHIJKLMNOPQRSTUVWXYZ
// string.ascii_letters 는, 대소문자 모두 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
// string.digits 는, 숫자 0123456789
쓰임예시로는
lo_arr = list(string.ascii_lowercase)
up_arr = list(string.ascii_uppercase)
al_arr = list(string.ascii_letters)
nu_arr = list(string.digits)
print(lo_arr)
# ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

alphabet = list(range(97, 123))  // 아스키코드 문자 a~z 까지를 십진수로 나타내면 97~122 이다. 나중에 chr()로 변환해서 응용하면 된다.
alphabet = list(range(65, 91))  // 아스키코드 문자 A~Z 까지를 십진수로 나타내면 65~90 이다. 나중에 chr()로 변환해서 응용하면 된다.

문자열 = 문자열.lower()  // 문자열 소문자로 변환
문자열 = 문자열.upper()  // 문자열 대문자로 변환

문자열 뒤집기
str = input().split()  // 123 입력 (문자열)
str = a[::-1]  // str = 321 (문자열)
str = int(str)  // str = 321 (정수형)

a = input()
dial = ['ABC', 'DEF', 'GHI', 'JKL', 'MNO', 'PQRS', 'TUV', 'WXYZ']
for i in range (len(a)):
        for j in dial:
                if a[i] in j:  # a[i]==j 라고하면 틀리다.
                        print(dial.index(j))  # j가 들어있는 dial의 인덱스값

a = 'hello world'
a.replace('hello','hi')  // 문자열 변경
a  # hi world

{ 백준 내코드에 반례가 있어(예를들어 aabcbb) 완벽한 코드는 아니지만, 중첩 for문과 if문 속에서 break와 continue의 사용법을 보기에 좋은 예시 }
# 백준 파이썬 1316번
n = int(input())
cnt = 0
result_cnt = 0
for i in range (n):
        a = input()
        for j in range (len(a)):
                        if a.count(a[j]) > 1:  # 중복된것이 있음
                                if a.index(a[j])+1 < a.find(a[j],(a.index(a[j])+1)):  # 중복된것이 연속되지않음
                                        break  # 안쪽 for문을 끝내고 바깥쪽 for문으로 이동함.
                                               # 만약 break가 아니라 continue를 적었다면,
                                               # 안쪽 for문을 마저 이어서하여 문자열 a의 다음 문자도 비교했을것이다.
                                               # 어차피 한 문자라도 삑사리나면 그건 result_cnt = 0 으로 치고 다음 새롭게 입력받은 문자열로 넘어가야하는데
                                               # continue를 써버리면 예를들어 abba 입력시 ab보고 끝냈을것을 남은 ba도 확인하게되어 result_cnt값에 여지를 주게 되는 것이다.
                                else:  # 중복된 값이 연속된것임
                                        cnt+=1
                        else:  # 중복된것이 없음
                                cnt+=1
        if cnt>=1:
                result_cnt+=1
        cnt=0       
print(result_cnt)

while ~ else 문은
while문 매개변수의 조건식에 해당하는 동안,
끝날때까지 쭉 단한번도 break로 빠져나오지 못하고 실행만 끝까지 완료했을때
while문을 모두 실행하고 else 문으로 넘어가 그것도 마찬가지로 실행해주는 것이다.
예시 사이트: https://studymake.tistory.com/209

for ~ else 문은
for문이 실행되는 동안,
끝날때까지 쭉 단한번도 break로 빠져나오지 못하고 실행만 끝까지 완료했을때
for문을 모두 실행하고 else 문으로 넘어가 그것도 마찬가지로 실행해주는 것이다.
예시 사이트: https://cagongman.tistory.com/30

for i in range (2,2) 처럼 범위가 이러한 경우일때는, 2~1 범위라서
해당 for문 안의 코드가 실행되지 않는다.
하지만 만약 저러한 for문의 범위에 for~else 구문을 사용할 경우에는 else 부분의 코드만 실행된다.

arr = ['가나다','라마바','사아자']
a = []
for i in arr:
    a.append(i*2)
print(a)
# 출력이 ['가나다가나다', '라마바라마바', '사아자사아자'] 이렇게 뜬다.

join은 리스트를 문자열로 이어붙여서 저장할때 사용하며,
arr = ['AB', 'CD', 'EF', 'GH']
result = "shj".join(arr)
처럼 사용하면
ABshjCDshjEFshjGH 라고 출력된다.

for i in range(123, 300):
    temp = sum(map(int, str(i)))  # 문자열의 각 자리를 int로 바꾸어 sum값을 구함. 그리고 temp에 할당함.

```
